<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HUML Parser</title>
    <script src="https://github.com/huml-lang/huml-ml/releases/download/v0.1.0/huml_js.bc.js" defer></script>
    <script src="https://unpkg.com/codemirror@5/lib/codemirror.js"></script>
    <script src="https://kaustubh.page/huml/codemirror5-huml.min.js"></script>
    <script src="https://unpkg.com/codemirror@5/mode/javascript/javascript.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/codemirror@5/lib/codemirror.css">
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        margin: 20px;
        background-color: #f5f5f5;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
      .header {
        text-align: center;
        margin-bottom: 20px;
      }
      .run-button {
        background-color: #007acc;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin-bottom: 20px;
      }
      .run-button:hover {
        background-color: #005a9e;
      }
      .editor-container {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
      }
      .editor-panel {
        flex: 1;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow: hidden;
        background: white;
      }
      .panel-header {
        background-color: #f0f0f0;
        padding: 10px;
        font-weight: bold;
        border-bottom: 1px solid #ddd;
      }
      .CodeMirror {
        height: 400px;
        border: none;
      }
      .error {
        color: #d32f2f;
        background-color: #ffebee;
        padding: 10px;
        border: 1px solid #ffcdd2;
        border-radius: 5px;
        font-family: monospace;
        white-space: pre-wrap;
      }
      .info {
        margin-top: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>HUML Parser</h1>
        <button class="run-button" onclick="parseHuml()">Run</button>
      </div>

      <div class="editor-container">
        <div class="editor-panel">
          <div class="panel-header">HUML Input</div>
          <textarea id="huml-input"></textarea>
        </div>
        <div class="editor-panel">
          <div class="panel-header">JSON Output</div>
          <textarea id="json-output"></textarea>
        </div>
      </div>

      <div id="error-display" class="error" style="display: none;"></div>

      <div class="info">
        <p>
          This is a simple playground to try out the OCaml implementation of the HUML parser. OCaml
          is pretty cool for being able to compile to multiple targets. This allows easy manual testing
          of the parser.
        </p>
        <p>
          Links:
          <ul>
            <li>GitHub: <a href="https://github.com/huml-lang/huml-ml" target="_blank">huml-lang/huml-ml</a></li>
            <li>HUML Website: <a href="https://huml.io/">huml.io</a>
            <li>HUML Spec: <a href="https://huml.io/specifications/v0-1-0/">v0.1.0 specification</a></li>
          </ul>
        </p>
      </div>
    </div>

    <script>
      let humlEditor, jsonEditor;

      window.addEventListener('load', function() {
        // Initialize CodeMirror editors
        humlEditor = CodeMirror.fromTextArea(document.getElementById('huml-input'), {
          mode: 'huml',
          lineNumbers: true,
          theme: 'default',
          tabSize: 2,
          indentWithTabs: false
        });

        jsonEditor = CodeMirror.fromTextArea(document.getElementById('json-output'), {
          mode: { name: 'javascript', json: true },
          lineNumbers: true,
          theme: 'default',
          readOnly: true,
          tabSize: 2,
          indentWithTabs: false
        });

        // Set some sample content
        humlEditor.setValue(`# Kitchensink test file.
foo_one:: # Hello
  # Scalar values testing - basic types
  foo_string: "bar_value"
  bar_string: "baz with spaces"
  baz_int: 42
  qux_float: 3.14159
  quux_bool: true
  corge_bool: false
  grault_null: null

  # Numbers with various formats
  foo_integers::
    bar_positive: 1234567
    baz_negative: -987654
    qux_zero: 0
    quux_underscore: 1_000_000
    corge_hex: 0xDEADBEEF
    grault_octal: 0o777
    garply_binary: 0b1010101
    waldo_large: 9_223_372_036_854_775_807

  foo_floats::
    bar_simple: 123.456
    baz_negative: -78.90
    qux_scientific: 1.23e10
    quux_scientific_neg: -4.56e-7
    corge_zero: 0.0
    grault_precision: 0.123456789
    garply_large_exp: 6.022e23

  # String edge cases
  foo_strings::
    bar_empty: ""
    baz_spaces: "   spaces   "
    qux_escaped: "Hello \\"World\\" with 'quotes'"
    quux_path: "C:\\\\path\\\\to\\\\file.txt"
    corge_unicode: "Unicode: Î±Î²Î³Î´Îµ ä¸­æ–‡ ðŸš€"
    grault_newlines: "Line1\\nLine2\\tTabbed"
    garply_long: "This is a very long string that contains many words and might test the parser's ability to handle extended content without issues"

foo_two:: # Yet another section.
  # Inline collections
  foo_inline_list:: 1, 2, 3, 4, 5
  bar_inline_list:: "alpha", "beta", "gamma"
  baz_inline_list:: true, false, null, 42
  qux_inline_list:: 1, "mixed", true, null, 3.14
  quux_inline_dict:: foo: "bar", baz: 123, qux: true
  corge_inline_dict:: nested: "deep_value", simple: "test"

  # Empty collections
  foo_empty_list:: []
  bar_empty_dict:: {}
  baz_empty_spaced:: []  # With trailing comment
  qux_empty_spaced:: {}    # Spaced comment

  # Multi-line collections
  foo_list::
    - "first_item"
    - "second_item"
    - "third_item"
    - null
    - 42
    - true
    - false

  bar_mixed_list::
    - "string_value"
    - 123
    - ::
      nested_foo: "nested_bar"
      nested_baz: 456
    - :: inline: "dict", in: "list"
    - ::
      deep_nested::
        level_two::
          level_three: "deep_value"

  # Nested dictionaries
  foo_dict::
    bar_key: "bar_value"
    baz_key: 789
    qux_nested::
      quux_sub: "quux_value"
      corge_sub: true
      grault_deep::
        garply_deeper: "deepest_value"
        waldo_numbers:: 1, 2, 3, 4

  # List of dictionaries edge cases
  foo_complex_list::
    - ::
      bar_type: "first"
      baz_value: 100
      qux_flag: true
    - :: # Inline comment
      bar_type: "second"
      baz_value: 200
      qux_nested::
        quux_inner: "inner_value"
        corge_list:: "a", "b", "c"
    - ::
      bar_type: "third"
      baz_empty:: {}
      qux_null: null
    - :: inline_dict: "in_list", foo: 42, bar: null

  # Special key formats
  foo_special_keys::
    "quoted-key": "quoted_value"
    "key with spaces": "spaced_value"
    "key.with.dots": "dotted_value"
    "key-with-dashes": "dashed_value"
    "key_with_underscores": "underscore_value"
    "123numeric_start": "numeric_key"
    "special!@#$%": "special_chars"

  # Comment variations
  foo_comments: "value" # End of line comment
  bar_comments: "value" # No space comment
  baz_comments: "value"  # Double space comment
  qux_comments: "value"   # Triple space
  # Full line comment
  quux_comments: "value"

foo_three::
  # Multiline strings
  foo_multiline_preserved: \`\`\`
    Preserved formatting
      With different indentation
        And multiple levels
      Back to level two
    Back to level one
  \`\`\`

  bar_multiline_stripped: """
    Stripped formatting
      This will be normalized
        All leading whitespace removed
      Consistent indentation
    Final line
  """

  baz_multiline_edge: \`\`\`
    Line with no indent
        Line with indent
    Line back to no indent
  \`\`\`

  # Boolean variations
  foo_booleans::
    bar_true: true
    baz_false: false
    qux_TRUE: true
    quux_FALSE: false
    corge_True: true
    grault_False: false

  # Null variations
  foo_nulls::
    bar_null: null
    baz_NULL: null
    qux_Null: null

  # Complex nesting test
  foo_complex_nesting::
    bar_level1::
      baz_level2::
        qux_level3::
          quux_level4::
            corge_deep_value: "very_deep"
            grault_deep_list::
              - "deep_item1"
              - ::
                deep_dict_key: "deep_dict_value"
                deep_dict_list:: "nested", "in", "deep", "dict"
              - "deep_item3"
            garply_deep_inline:: deep: "inline", dict: true

  # Mixed inline and multiline in same structure
  foo_mixed_structure::
    bar_inline_in_multi:: quick: "inline"
    baz_multi_list::
      - "first"
      - :: inline: "dict"
      - ::
        multiline_key: "multiline_value"
        another_key: 123

  # Edge case keys and values
  foo_edge_cases::
    "": "empty_key"
    " ": "space_key"
    "  ": "double_space_key"
    "123": "numeric_string_key"
    "true": "boolean_string_key"
    "null": "null_string_key"
    key_with_empty_value: ""
    key_with_space_value: " "

  # Large inline structures
  foo_large_inline:: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, "eleven", "twelve", true, false, null, 3.14
  bar_large_inline:: a: 1, b: 2, c: 3, d: 4, e: 5, f: "six", g: true, h: null

foo_final::
  # Final complex test structure
  foo_final_test::
    bar_everything::
      - ::
        string_val: "test"
        int_val: 42
        float_val: 3.14
        bool_val: true
        null_val: null
        inline_list:: 1, "two", 3.0, true, null
        inline_dict:: key: "value", num: 123
        nested_dict::
          deep_key: "deep_value"
          deep_list::
            - "item1"
            - :: nested: "item"
            - "item3"
      - "simple_string_item"
      - 999
      - ::
        final_nested::
          ultimate_test:: success: true, complete: "yes"
`);

        parseHuml();
      });

      function parseHuml() {
        const input = humlEditor.getValue();
        const errorDisplay = document.getElementById('error-display');

        try {
          const result = huml.parse(input);

          if (result.error.length > 0) {
            // Display error
            errorDisplay.textContent = result.error;
            errorDisplay.style.display = 'block';
            jsonEditor.setValue('');
          } else {
            // Display JSON result
            errorDisplay.style.display = 'none';
            jsonEditor.setValue(result.output);
          }
        } catch (error) {
          errorDisplay.textContent = 'JavaScript Error: ' + error.message;
          errorDisplay.style.display = 'block';
          jsonEditor.setValue('');
        }
      }
    </script>
  </body>
</html>
